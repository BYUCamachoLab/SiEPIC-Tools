"""
netlist.py

Author: Hyrum Gunther, Sequoia Ploeg
Modified on 5/23/2019

Dependencies:
- pya
    Python connection to KLayout, allowing access to cells and other layout 
    objects.
- numpy
    Lots of math happens here!

This file does everything related to the netlist; writing, reading, you name it.
"""


from SiEPIC.ann.models.components import create_component_by_name

class ObjectModelNetlist:
    """
    The Parser class reads a netlist generated by the SiEPIC toolbox and uses 
    various classes which inherit from 'models.components.Component' to create an 
    object based model of a photonic circuit. 
    
    Each derived class is connected to a component model in 'models' that exposes a 
    'get_s_params' method with its appropriate arguments to the derived model. These 
    s_params are the s-matrices of the component, which are then used to simulate the 
    circuit's transmission behavior.

    Attributes
    ----------
    component_list : list
        A list of objects derived from 'models.components.Component' representing the
        photonic circuit.
    net_count : int
        A counter keeping track of the total number of nets in the circuit (0-indexed).

    Methods
    -------
    parse_file(filepath)
        Parses through the netlist to identify components and organize them into objects.
        Objects are connected with their data models, allowing them to retrieve any
        available parameters.
    _parse_line(line_elements)
        Reads the elements on a line of the netlist (already delimited before passed to
        _parse_line) and creates the appropriate object. Appends the newly created object
        to the Parser's component_list.

    # 'cascadeCells' takes the cellList gathered by 'parseFile' and cascades all the s-matrices together
    # using scikit-rf's 'connect_s' and 'innerconnect_s' functions, deleting already connected Cells as
    # it goes. The result is a single Cell object with an s-matrix representing the cascaded circuit
    """

    def __init__(self):
        """
        Initializes a Parser and creates a structure to hold a list of components
        and count the number of nets in the circuit (0-indexed).
        """
        self.component_list = []
        self.net_count = 0


    def parse_file(self, filepath: str) -> list:
        """
        Parses a netlist (given a filename) and converts it to an object model of the circuit.

        Parameters
        ----------
        filepath : str
            The name of the file to be parsed.

        Returns
        -------
        component_list : list
            A list of all components found in the netlist, with their accompanying
            properties and values.
        """
        with open(filepath) as fid:
            text = fid.read()
            return self.parse_text(text)

    def parse_text(self, text: str) -> list:
        """
        Parses the string format of the netlist. Instead of requiring a file, string
        representations of netlists can also be converted into an object model.

        Parameters
        ----------
        text : str
            The text of the netlist.
        
        Returns
        -------
        component_list : list
            A list of all components found in the netlist, with their accompanying
            properties and values.
        """
        lines = text.splitlines()
        for line in lines:
                elements = line.split()
                if len(elements) > 0:
                    if (".ends" in elements[0]):
                        break
                    elif ("." in elements[0]) or ("*" in elements[0]):
                        continue
                    else:
                        self._parse_line(elements)
        return self.component_list

    def _parse_line(self, line_elements: list):
        """
        Parses a line from the netlist, already split into individual elements, and 
        converts it into a new Component object.
        
        Parameters
        ----------
        line_elements : list
            A list of all the elements on a line (already split by some delimiter).
        """

        component = None
        nets = []
        for item in line_elements[1:]:
            if "N$" in item:
                net = str(item).replace("N$", '')
                nets.append(net)
                if int(net) > self.net_count:
                    self.net_count = int(net)
                continue
            elif component is None:
                component = create_component_by_name(item)
            elif "lay_x=" in item:
                component.lay_x = float(str(item).replace("lay_x=", ''))
            elif "lay_y=" in item:
                component.lay_y = float(str(item).replace("lay_y=", ''))
            elif "radius=" in item:
                component.radius = float(str(item).replace("radius=", ''))
            elif "wg_length=" in item:
                lenth = str(item).replace("wg_length=", '')
                component.length = strToSci(lenth)
            elif "wg_width=" in item:
                width = str(item).replace("wg_width=", '')
                # Width needs to be stored in microns (um)
                component.width = strToSci(width)*1e6
            elif "points=" in item:
                # The regex, in case you ever need it: /(\[[\d]+[\,][\d]+\])/g
                points = str(item).replace("points=", '')
                points = points.replace("\"[[", '')
                points = points.replace("]]\"", '')
                point_list = points.split('],[')
                for point in point_list:
                    out = point.split(',')
                    component.points.append((float(out[0]), float(out[1])))
        component.nets = nets
        self.component_list.append(component)


import pya
import SiEPIC.extend as se
import SiEPIC.core as cor
import jsons

dom = None

def spice_netlist_export(self) -> (str, str):
    """
    This function gathers information from the current top cell in Klayout into a netlist
    for a photonic circuit. This netlist is used in simulations.

    Most of this function comes from a function in 'lukasc-ubc/SiEPIC-Tools/klayout_dot_config/python/SiEPIC/extend.py' which does the
    same thing. This function has parts of that one removed because they were not needed for our toolbox.
    """

    import SiEPIC
    from SiEPIC import _globals
    from time import strftime
    from SiEPIC.utils import eng_str

    from SiEPIC.utils import get_technology
    TECHNOLOGY = get_technology()
    if not TECHNOLOGY['technology_name']:
        v = pya.MessageBox.warning("Errors", "SiEPIC-Tools requires a technology to be chosen.  \n\nThe active technology is displayed on the bottom-left of the KLayout window, next to the T. \n\nChange the technology using KLayout File | Layout Properties, then choose Technology and find the correct one (e.g., EBeam, GSiP).", pya.MessageBox.Ok)
        return 'x', 'x', 0, [0]
    # get the netlist from the entire layout
    nets, components = self.identify_nets()

    if not components:
        v = pya.MessageBox.warning("Errors", "No components found.", pya.MessageBox.Ok)
        return 'no', 'components', 0, ['found']

    text_subckt = '* Spice output from KLayout SiEPIC-Tools v%s, %s.\n\n' % (
        SiEPIC.__version__, strftime("%Y-%m-%d %H:%M:%S"))
        
    circuit_name = self.name.replace('.', '')  # remove "."
    if '_' in circuit_name[0]:
        circuit_name = ''.join(circuit_name.split('_', 1))  # remove leading _

    ioports = -1
    for c in components:
        # optical nets: must be ordered electrical, optical IO, then optical
        nets_str = ''
        for p in c.pins:
            if p.type == _globals.PIN_TYPES.ELECTRICAL:
                nets_str += " " + c.component + '_' + str(c.idx) + '_' + p.pin_name
        for p in c.pins:
            if p.type == _globals.PIN_TYPES.OPTICALIO:
                nets_str += " N$" + str(ioports)
                ioports -= 1
        #pinIOtype = any([p for p in c.pins if p.type == _globals.PIN_TYPES.OPTICALIO])
        for p in c.pins:
            if p.type == _globals.PIN_TYPES.OPTICAL:
                if p.net.idx != None:
                    nets_str += " N$" + str(p.net.idx)
                #if p.net.idx != None:
                #    nets_str += " N$" + str(p.net.idx)
                else:
                    nets_str += " N$" + str(ioports)
                    ioports -= 1

        # Check to see if this component is an Optical IO type.
        pinIOtype = any([p for p in c.pins if p.type == _globals.PIN_TYPES.OPTICALIO])

        component1 = c.component
        params1 = c.params

        text_subckt += ' %s %s %s ' % (component1.replace(' ', '_') +
                                       "_" + str(c.idx), nets_str, component1.replace(' ', '_'))
        x, y = c.Dcenter.x, c.Dcenter.y
        text_subckt += '%s lay_x=%s lay_y=%s\n' % \
            (params1, eng_str(x * 1e-6), eng_str(y * 1e-6))

    # text_subckt += '.ends %s\n\n' % (circuit_name)

    global dom
    dom = ObjectModelNetlist()
    components = dom.parse_text(text_subckt)
    output = jsons.dump(components, verbose=True, strip_privates=True)

    return text_subckt, output

pya.Cell.spice_netlist_export_ann = spice_netlist_export


def match_ports(net_id: str, component_list: list) -> list:
    """
    searches for a pin of a specific name in the pin lists of 
    a list of cells. Each pin must be found in two locations.
    On a successful find, the indices of the two cells and the
    indices of the pins in their pin lists are returned
    Args:
        net_id (str): id of the net to find
        component_list (list of 'Cell' type objects): list of the cells to search
    Returns:
        cella (int): index of the first cell where the pin was found
        inda (int): index in the pin list of the first cell where the pin was found
        cellb (int): index of the second cell where the pin was found
        indb (int): index in the pin list of the second cell where the pin was found
    """
    filtered_comps = [component for component in component_list if net_id in component.nets]
    comp_idx = [component_list.index(component) for component in filtered_comps]
    net_idx = []
    for comp in filtered_comps:
        net_idx += [i for i, x in enumerate(comp.nets) if x == net_id]
    if len(comp_idx) == 1:
        comp_idx += comp_idx
    
    return [comp_idx[0], net_idx[0], comp_idx[1], net_idx[1]]


import copy
import numpy as np
from SiEPIC.ann.models.components import Component
class ComponentSimulation:
    nets: list
    f: np.array
    s: np.array

    def __init__(self, component: Component=None):
        if component:
            self.nets = copy.deepcopy(component.nets)
            self.f, self.s = component.get_s_params()


import skrf as rf
def connect_circuit(netlist: ObjectModelNetlist) -> ComponentSimulation:
    """
    Connects the s-matrices of a photonic circuit given its ObjectModelNetlist and returns
    a single 'ComponentSimulation' object containing the frequency array, the assembled
    s-matrix, and a list of the external nets (strings of negative numbers).
    """
    if netlist.net_count == 0:
        return

    component_list = [ComponentSimulation(component) for component in netlist.component_list]
    for n in range(0, netlist.net_count + 1):
        ca, ia, cb, ib = match_ports(str(n), component_list)

        #if pin occurances are in the same Cell
        if ca == cb:
            component_list[ca].s = rf.innerconnect_s(component_list[ca].s, ia, ib)
            del component_list[ca].nets[ia]
            if ia < ib:
                del component_list[ca].nets[ib-1]
            else:
                del component_list[ca].nets[ib]

        #if pin occurances are in different Cells
        else:
            combination = ComponentSimulation()
            combination.f = component_list[0].f
            combination.s = rf.connect_s(component_list[ca].s, ia, component_list[cb].s, ib)
            del component_list[ca].nets[ia]
            del component_list[cb].nets[ib]
            combination.nets = component_list[ca].nets + component_list[cb].nets
            del component_list[ca]
            if ca < cb:
                del component_list[cb-1]
            else:
                del component_list[cb]
            component_list.append(combination)

    return component_list[0]
















####################################################
#
#   FORMERLY qopticParser1.py FUNCTIONS BELOW
#
####################################################

import pya
import numpy as np
import cmath as cm

class Reader:
    '''
    class to extend the pya.Cell class with the functionality to read/parse 
    files containing s-parameter data for photonic components
    '''

    def readSparamData(filename, numports, isgc):
        '''
        Function that takes a file containing s-parameters, parses it, and 
        returns an array of frequency values and a 3D matrix of s-parameters
        Args:
            filename (str): name of file to be parsed
            numports (int): the number of ports the photonic component has
            isgc (boolean): flag indicating the component is a grating coupler
                            grating couplers are a special case
        Returns:
            S (3D list of complex-128): S-matrix for the component associated with the file
            F (list of float): Frequency array for the component associated with the file
        '''

        F = []
        S = []
        fid = open(filename, "r")
        
        if isgc is True:
            '''
            grating couplers have a different file format from the other component types
            so a special case is required to parse them
            '''

            #grating coupler compact models have 100 points for each s-matrix index
            arrlen = 100
            
            lines = fid.readlines()
            F = np.zeros(arrlen)
            S = np.zeros((arrlen,2,2), 'complex128')
            for i in range(0, arrlen):
                words = lines[i].split()
                F[i] = float(words[0])
                S[i,0,0] = cm.rect(float(words[1]), float(words[2]))
                S[i,0,1] = cm.rect(float(words[3]), float(words[4]))
                S[i,1,0] = cm.rect(float(words[5]), float(words[6]))
                S[i,1,1] = cm.rect(float(words[7]), float(words[8]))
            F = F[::-1]
            S = S[::-1,:,:]
        
        else:
            '''
            Common case
            Parsing a '.sparam' file
            '''

            line = fid.readline()
            line = fid.readline()
            numrows = int(tuple(line[1:-2].split(','))[0])
            S = np.zeros((numrows, numports, numports), dtype='complex128')
            r = m = n = 0
            for line in fid:
                if(line[0] == '('):
                    continue
                data = line.split()
                data = list(map(float, data))
                if(m == 0 and n == 0):
                    F.append(data[0])
                S[r,m,n] = data[1] * np.exp(1j*data[2])
                r += 1
                if(r == numrows):
                    r = 0
                    m += 1
                    if(m == numports):
                        m = 0
                        n += 1
                        if(n == numports):
                            break
        fid.close()
        return [S, F]
        
#extending the pya.Cell class
pya.Cell.Reader = Reader


####################################################
#
#   FORMERLY cascade_netlist.py FUNCTIONS BELOW
#
####################################################

# import subprocess
# import datetime
import os
import sys

import numpy as np
import matplotlib.pyplot as plt

import pya
from enum import Enum
import skrf as rf
from SiEPIC.ann import waveguideNN as wn
from scipy.interpolate import splev, splrep, interp1d

'''
********************************************************************************
This file defines 3 classes:
'Cell' is used to represent a single photonic component by its s-parameters
'Parser' uses a netlist to create a list of 'Cells' and then cascades them 
    into one Cell with the s-matrix of the whole circuit
'Params' extends the pya.Cell class adding the functionality to use the 'Parser'
    class and retrieve the s-parameter data of the circuit as a whole
********************************************************************************
'''


'''
'path' and 'model' are the filepath to the waveguide ANN model and
the model itself, respectively
Both are used as global variables in the 'cascade_netlist' module
'''
path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "NN_SiO2_neff.h5")
model = wn.loadWaveguideNN(path)

numInterpPoints = 2000

interpRange = (1.88e+14, 1.99e+14)

def strToSci(str):
    '''
    local function to convert strings written in Klayout's 
    exponential notation into floats
    Args:
        str (str): string to convert to float
    Returns:
        float representation of the input string
    '''

    ex = str[-1]
    base = float(str[:-1])
    if(ex == 'm'):
        return base * 1e-3
    elif(ex == 'u'):
        return base * 1e-6
    elif(ex == 'n'):
        return base * 1e-9
    else:
        return float(str(base) + ex)


def findPortMatch(name, listofcells):
    '''
    searches for a pin of a specific name in the pin lists of 
    a list of cells. Each pin must be found in two locations.
    On a successful find, the indices of the two cells and the
    indices of the pins in their pin lists are returned
    Args:
        name (str): name of the pin to find
        listofcells (list of 'Cell' type objects): list of the cells to search
    Returns:
        cella (int): index of the first cell where the pin was found
        inda (int): index in the pin list of the first cell where the pin was found
        cellb (int): index of the second cell where the pin was found
        indb (int): index in the pin list of the second cell where the pin was found
    '''

    cella = cellb = inda = indb = -1
    found = False

    #nested for loop search of the pin lists of each cell
    for component in range(0, len(listofcells)):
        for net in range(0, len(listofcells[component].p)):
            if(listofcells[component].p[net] == name):
                cella = component
                inda = net
                found = True
                break
        if found:
            break

    #when the pin is found once, continue searching for the second occurence
    found = False
    for d in range(cella+1, len(listofcells)):
        for p in range(0, len(listofcells[d].p)):
            if(listofcells[d].p[p] == name):
                cellb = d
                indb = p
                found = True
                break
        if found:
            break

    #last loop to check if the two occurences of the pin are in the same cell
    if(cellb == -1):
        for p in range(inda+1, len(listofcells[cella].p)):
            if(listofcells[cella].p[p] == name):
                cellb = cella
                indb = p
                break
    return [cella, inda, cellb, indb]


class DEVTYPE(Enum):
    '''
    Enum type listing all available component types
    '''

    BDC = 'ebeam_bdc_te1550'
    DC = 'ebeam_dc_halfring_te1550'
    GC = 'ebeam_gc_te1550'
    YB = 'ebeam_y_1550'
    TR = 'ebeam_terminator_te1550'


class Cell():
    '''
    class representing a photonic component as its s-matrix (with related array of 
    frequency values), number of ports, and device ID. Used to simulate the transmission 
    behavior of a photonic circuit. This class is local and should not be confused with 
    the 'pya.Cell' class
    '''

    def __init__(self):
        '''
        init function taking an ID
        '''
        self.devType = None
        self.p = []
        self.iswg = False
        self.wglen = None
        self.wgwid = None
        self.s = None
        self.f = []


    def readSparamFile(self):
        '''
        if the component represented by this Cell object is not a waveguide, its s-parameter information 
        can be extracted from a file from the compact model. This function calls a function that reads and
        parses the appropriate file and then interpolates the data to get a smooth curve of 1000 points for
        each s-matrix element
        Args:
            none
        Returns:
            none
            self.s becomes interpolated s-matrix
            self.f becomes interpolated array of frequency values associated with the s-matrix
        '''

        isgc = False #grating couplers have differently formatted s-param files, requiring a special case
        if(self.devType == DEVTYPE.BDC.value):
            filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), "sparams/EBeam_1550_TE_BDC.sparam")
        elif self.devType == DEVTYPE.DC.value:
            filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), "sparams/te_ebeam_dc_halfring_straight_gap=30nm_radius=3um_width=520nm_thickness=210nm_CoupleLength=0um.dat")
        elif self.devType == DEVTYPE.GC.value:
            filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), "sparams/GC_TE1550_thickness=220 deltaw=0.txt")
            isgc = True
        elif self.devType == DEVTYPE.YB.value:
            filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), "sparams/Ybranch_Thickness =220 width=500.sparam")
        elif self.devType == DEVTYPE.TR.value:
            filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), "sparams/nanotaper_w1=500,w2=60,L=10_TE.sparam")
        else:
            print("ERROR: Unknown Device Type")
            return    
        s, f = pya.Cell.Reader.readSparamData(filename, len(self.p), isgc)
        
        # s and f from the s-param file are interpolated to get a smooth curve
        # and also to match the frequency values for all components
        self.f = np.linspace(interpRange[0], interpRange[1], numInterpPoints)
        func = interp1d(f, s, kind='cubic', axis=0)
        self.s = func(self.f)            


    def wgSparam(self, width_in, thickness_in, deltaLength_in, frequency=None, length=None):
        '''
        Function that calculates the s-parameters for a waveguide using the ANN model
        Args:
            None
            frequency (frequency array) and length (waveguide length) are used to calculate the s-parameters
        Returns:
            None
            self.s becomes the s-matrix calculated by this function
        '''
        frequency = self.f
        length = self.wglen
        # from SiEPIC.ann.models.wg_ann.model import Model

        # _, self.s = Model.get_s_params(frequency=self.f, length=self.wglen, width=width_in, thickness=0.22, delta_length=0)
        mat = np.zeros((len(frequency),2,2), dtype=complex)        
        
        c0 = 299792458 #m/s
        width = width_in #0.5 #um
        thickness = thickness_in #0.22 #um
        mode = 0 #TE
        TE_loss = 700 #dB/m for width 500nm
        alpha = TE_loss/(20*np.log10(np.exp(1))) #assuming lossless waveguide
        waveguideLength = length + (length * deltaLength_in)
        
        #calculate wavelength
        wl = np.true_divide(c0,frequency)

        # effective index is calculated by the ANN
        neff = wn.getWaveguideIndex(model,np.transpose(wl),width,thickness,mode)

        #K is calculated from the effective index and wavelength
        K = (2*np.pi*np.true_divide(neff,wl))

        #the s-matrix is built from alpha, K, and the waveguide length
        for x in range(0, len(neff)): 
            mat[x,0,1] = mat[x,1,0] = np.exp(-alpha*waveguideLength + (K[x]*waveguideLength*1j))
        self.s = mat
        

    #calculate waveguide s-parameters based on SiEPIC's compact model
    def wgSparamSiEPIC(self, width=None, thickness=None, deltaLength=None, frequency=None, length=None):
        '''
        Calculates waveguide s-parameters based on the SiEPIC compact model for waveguides
        Args:
            None
            frequency (frequency array) and self.wglen (waveguide length) are used to calculate the s-parameters
        Returns:
            None
            self.s becomes the s-matrix calculated by this function        
        '''
        frequency = self.f

        #using file that assumes width 500nm and height 220nm
        filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), "sparams/WaveGuideTETMStrip,w=500,h=220.txt")
        with open(filename, 'r') as f:#read info from waveguide s-param file
          coeffs = f.readline().split()
        
        mat = np.zeros((len(frequency),2,2), dtype=complex) #initialize array to hold s-params
        
        c0 = 299792458 #m/s

        #loss calculation
        TE_loss = 700 #dB/m for width 500nm
        alpha = TE_loss/(20*np.log10(np.exp(1)))  

        w = np.asarray(frequency) * 2 * np.pi #get angular frequency from frequency
        lam0 = float(coeffs[0]) #center wavelength
        w0 = (2*np.pi*c0) / lam0 #center frequency (angular)
        
        ne = float(coeffs[1]) #effective index
        ng = float(coeffs[3]) #group index
        nd = float(coeffs[5]) #group dispersion
        
        #calculation of K
        K = 2*np.pi*ne/lam0 + (ng/c0)*(w - w0) - (nd*lam0**2/(4*np.pi*c0))*((w - w0)**2)
        
        for x in range(0, len(frequency)): #build s-matrix from K and waveguide length
          mat[x,0,1] = mat[x,1,0] = np.exp(-alpha*self.wglen + (K[x]*self.wglen*1j))
        
        self.s = mat


    def printPorts(self):
        '''
        print port id's of Cell
        '''
        print("DEVICE has", len(self.p), "ports.")
        print(self.p)


class Parser:
    '''
    Parser class uses local 'Cell' class and an input netlist to cascade
    the s-matrices of a photonic circuit, simulating its transmission behavior

    'parseFile' parses through the netlist to identify components and gathers their s-parameters
    using 'parseCell'. It collects all these components into its 'cellList'

    'parceCell' takes a netlist entry about a single component and collects or calculates its
    s-parameter data.

    'cascadeCells' takes the cellList gathered by 'parseFile' and cascades all the s-matrices together
    using scikit-rf's 'connect_s' and 'innerconnect_s' functions, deleting already connected Cells as
    it goes. The result is a single Cell object with an s-matrix representing the cascaded circuit
    '''

    def __init__(self, filepath):
        '''
        init function takes a filepath to a netlist that represents a photonic circuit
        '''

        self.cellList = []
        self.filepath = filepath
        self.nports = 0


    def parseFile(self, width, thickness, deltaLength):
        '''
        reads the netlist file and calls 'parseCell' to create Cell objects from 
        the netlist entries
        Args:
            none
            self.filepath is the needed path to the netlist
        Returns
            none
            the call to 'parseCell' will add a new Cell to self.cellList
        '''

        fid = open(self.filepath)
        lines = fid.readlines()
        for line in lines:
            elements = line.split()
            if len(elements) > 0:
                if (".ends" in elements[0]):
                    break
                elif ("." in elements[0]) or ("*" in elements[0]):
                    continue
                else:
                    self.parseCell(elements, width, thickness, deltaLength)
        

    def parseCell(self, line, width, thickness, deltaLength):
        '''
        This function takes an entry from the netlist and creates a new Cell object
        corresponding to the entry
        
        If the entry is for a waveguide, 'Cell.wgSparam' is called
        to calculate s-parameters based on either the ANN model or the SiEPIC compact
        model
        
        If the entry is for another type of component, 'Cell.readSparamFile' is called
        to read the s-parameter data from a compact model file
        '''
        newCell = Cell()

        #search the DEVTYPE enum for this entry
        for devtype in DEVTYPE:
            if devtype.value in line[0]:
                newCell.devType = devtype.value
        
        #gather information about the entry into the Cell
        for item in line:
            if "N$" in item:
                port = str(item).replace("N$", '')
                newCell.p.append(port)
                if int(port) > self.nports:
                    self.nports = int(port)
            if "ebeam_wg" in item:
                newCell.iswg = True
            if "wg_length=" in item:
                wglen = str(item).replace("wg_length=", '')
                newCell.wglen = strToSci(wglen)
            if "wg_width=" in item:
                wgwid = str(item).replace("wg_width=", '')
                newCell.wgwid = strToSci(wgwid)
        
        #call function to collect or calculate s-parameters
        if not newCell.iswg:
            newCell.readSparamFile()
        else:
            newCell.f = np.linspace(interpRange[0], interpRange[1], numInterpPoints)
            # newCell.wgSparam(width, thickness, deltaLength)
            newCell.wgSparamSiEPIC()
        self.cellList.append(newCell)


    def cascadeCells(self):
        '''
        For each pin in the circuit, the s-matrices of the Cells containing that pin are cascaded
        using scikit-rf funtions. 'innerconnect_s' if the two occurances of the pin are in the
        same Cell, 'connect_s' if they are in two different cells

        For a pin:
        * 'findPortMatch' is called to find where the two occurances of the pin are
        * If they are in the same Cell, use 'innerconnect_s' to cascade the s-matrices and delete the
            connected ports from the Cell's port list
        * If they are in different Cells, create a new Cell object and let its s-matrix be the result 
            of 'connect_s' for the two Cells. Delete the two Cells from the cellList

        Repeat this process until all pins have been connected

        One Cell will remain in the cellList. Its s-matrix represents the transmission behavior of the
        circuit as a whole
        '''
        if self.nports == 0:
            return
        for n in range(0, self.nports + 1):
            ca, ia, cb, ib = findPortMatch(str(n), self.cellList)

            #if pin occurances are in the same Cell
            if ca == cb:
                self.cellList[ca].s = rf.innerconnect_s(self.cellList[ca].s, ia, ib)
                del self.cellList[ca].p[ia]
                if ia < ib:
                    del self.cellList[ca].p[ib-1]
                else:
                    del self.cellList[ca].p[ib]

            #if pin occurances are in different Cells
            else:
                d = Cell()
                d.f = self.cellList[0].f
                d.s = rf.connect_s(self.cellList[ca].s, ia, self.cellList[cb].s, ib)
                del self.cellList[ca].p[ia]
                del self.cellList[cb].p[ib]
                d.p = self.cellList[ca].p + self.cellList[cb].p
                del self.cellList[ca]
                if ca < cb:
                    del self.cellList[cb-1]
                else:
                    del self.cellList[cb]
                self.cellList.append(d)


    def getCells(self):
        '''
        Return the cellList for a Parser object
        '''
        return self.cellList


    def getCellCount(self):
        '''
        Return the length of the cellList for a Parser object
        '''
        return len(self.cellList)


class Params:
    '''
    class to extend the pya.Cell class, allowing the Cell class
    to parse a netlist and calculate s-parameters for the photonic 
    circuit represented by the current top cell

    also has a method to get the external ports of the circuit
    for use in drawing schematics and plotting simulation 
    results
    '''

    def get_sparameters(filename, width, thickness, deltaLength):
        '''
        function to get the cascaded s-matrix of the photonic circuit 
        represented by the current top-cell in Klayout
        Takes a file name of the netlist representing the circuit
        Args:
            filename (str): name of the netlist
        Returns:
            mat (3D list): s-matrix of the circuit represented by the netlist
            freq (list): array of frequency values corresponding to the entries in 'mat'
        '''

        test = Parser(filename)
        test.parseFile(width, thickness, deltaLength)
        test.cascadeCells()
        mat = test.cellList[0].s
        freq = test.cellList[0].f

        global dom
        method2 = connect_circuit(dom)
        f = method2.f
        s = method2.s
        return (mat, freq)
        

    def get_ports(filename, width, thickness, deltaLength):
        '''
        function to get the ports of the cascaded photonic circuit
        Takes a filename of a netlist
        Args: 
            filename (str): name of netlist
        Returns:
            ports (list): ordering of the external ports of the circuit
        '''
        test = Parser(filename)
        test.parseFile(width, thickness, deltaLength)
        test.cascadeCells()
        ports = test.cellList[0].p
        return ports
    
#extending pya.Cell class
pya.Cell.Params = Params
